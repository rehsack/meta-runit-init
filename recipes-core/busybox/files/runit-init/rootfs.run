#!/bin/sh

. /etc/default/rcS
. /etc/init.d/functions-ri

# Need clock or writable timestamp to have a sane timestamp for rootfs mount
[ -x /etc/init.d/hwclock.sh ] || [ -e /etc/timestamp ] || [ "$READ_ONLY_ROOTFS" = "no" ] || exit 1
[ -x /etc/init.d/hwclock.sh ] && /etc/init.d/hwclock.sh start 2>/dev/null
[ -e /etc/timestamp ] && [ "$(date -r /etc/timestamp +%s 2>/dev/null)" -gt "$(date +%s)" ] &&
	date "@$(date -r /etc/timestamp +%s 2>/dev/null)"

exec 9< /etc/fstab
rootmode=rw
rootpts=rw
rootcheck=$ENABLE_ROOTFS_FSCK
swap_on_raid=no
devfs=
netfs=no

while read fs mnt type opts dump pass junk <&9; do
	case "$fs" in
	""|\#*)
		continue
		;;
	/dev/dm*|/dev/mapper*)
	# LVM, LUKS, etc must have already been mounted in initramfs
		rootcheck=no
		;;
	/dev/md*)
		# Swap on md device.
		test "$type" = swap && swap_on_raid=yes
		;;
	/dev/*)
		;;
	*)
		case "$type" in
		nfs*)
			# NFS must have already been mounted in initramfs
			rootcheck=no
			;;
		p9*)
			# Plan9 FS must have already been mounted in initramfs
			rootcheck=no
			;;
		swap)
			swap_on_raid=yes
			;;
		esac
		;;
	esac

	test "$type" = devfs && devfs="$fs"
	test "$mnt" != / && continue
	rootopts="$opts"
	test "$pass" = 0 -o "$pass" = "" && test $FSCK_RO_ROOTFS != "yes" && rootcheck=no
	case "$opts" in
	ro|ro,*|*,ro|*,ro,*)
		rootmode=ro
		;;
	esac
done
exec 0>&9 9>&-

# Check for conflicting configurations
if [ "$rootmode" = "ro" -a "$ROOTFS_READ_ONLY" = "no" ] || \
    [ "$rootmode" = "rw" -a "$ROOTFS_READ_ONLY" = "yes" ]; then
	echo ""
	echo "WARN: conflicting configurations in /etc/fstab and /etc/default/rcS"
	echo "      regarding the writability of rootfs. Please fix one of them."
	echo ""
fi

# Mounting swap before fsck
echo "Activating swap"
[ -x /sbin/swapon ] && swapon -a

if test -f /fastboot || test $rootcheck = no ||
    ( test "$READ_ONLY_ROOTFS" = "yes" && test "$FSCK_RO_ROOTFS" != "yes" ); then
	test "$VERBOSE" != no && echo "Root filesystem check disabled"
else
	mount -n -o remount,ro /
	if test $? = 0; then
		if test -f /forcefsck; then
			force="-f"
		else
			force=""
		fi
		if test "$FSCKFIX" = "yes"; then
			fix="-y"
		else
			fix="-a"
		fi
		( test "$VERBOSE" != yes || grep -q 'quiet' /proc/cmdline ) || echo "Checking root filesystem..."
		fsck $force $fix /
		#
		# If there was a failure, use SULOGIN
		#
		# Failure = exit with a return code of 2 or higher.  A return
		# code of 1 indicates that filesystem errors were corrected but
		# rootfs should now be clean.
		#
		if test "$?" -gt 1; then
			echo "root fsck failed.  Please repair manually and reboot."
			echo "NOTE that the root filesystem is currently mounted read-only."
			if test READ_ONLY_ROOTFS != "yes"; then
				echo "To remount it read-write:"
				echo
				echo "   # mount -n -o remount,rw /"
				echo
			fi
			# Start a single user shell on the console (handled by init)
			return 1
		fi
	else
		echo "*** WARNING!  Cannot fsck root fs because it is not mounted read-only!"
	fi
fi

#	If the root filesystem was not marked as read-only in /etc/fstab,
#	remount the rootfs rw but do not try to change mtab because it
#	is on a ro fs until the remount succeeded. Then clean up old mtabs
#	and finally write the new mtab.
#
mount -n -o remount,$rootmode /
if test "$rootmode" = rw; then
	ln -sf /proc/mounts /dev/mtab
fi

# We want writable temp after rootfs mounted rw (or volatiles present)
if [ ! -w /tmp ] && ! [ -L /tmp ] && ! grep -q ' /tmp ' /proc/mounts; then
	mount -t tmpfs tmpfs /tmp
fi

if [ "$(readlink /tmp)" = "/var/tmp" ] && ! [ -w /var/tmp ] && ! grep -q ' /var/tmp ' /proc/mounts; then
	mount -t tmpfs tmpfs /var/tmp
fi

markran

exit 0
